#include <Reactduino.h>

/*
 * This example demonstrates various ways for using a class method as callback.
 *
 * LEDs are simulated by messages printed on the serial port. The output will
 * be somethings like:
 *
 *  . . . 
 *  at 178s > LED 2 is ON
 *  at 179s > LED 1 is ON
 *  at 180s > LED 1 is OFF
 *  at 180s > LED 2 is OFF
 *  at 180s > LED 3 is OFF
 *  at 181s > LED 1 is ON
 *  at 182s > LED 1 is OFF
 *  at 182s > LED 2 is ON
 *  at 183s > LED 1 is ON
 *  . . . 
 */

#define BLINK_DELAY     200

class SimulatedLed {
    public:
        SimulatedLed(uint8_t pin) {
            _pin = pin;
            _state = LOW;
        }

        void toggle() {
            _state = !_state;

            Serial.print("at ");
            Serial.print(millis() / 1000);

            Serial.print("s > LED ");
            Serial.print(_pin);
            Serial.println(_state == HIGH ? " is ON" : " is OFF");
        }

    private:
        uint8_t _pin;
        bool _state;
};


SimulatedLed led1(1);

/*
 * Global function wrapping the instance method call 
 */
void led1_cb() {
    led1.toggle();
}

SimulatedLed led2(2);

void app_main() {
    Serial.begin(9600);         // for debug trace

    /*
     * Option 1: use a global function accessing the global instance of the LED.
     *
     * We don't really use the method as a callback here, but just wrapping it
     * in a global function. This illustrates the default way one can think
     * about.
     */   
    app.repeat(1000, led1_cb);

    /*
     * Option 2: use a lambda function, which closure includes by default
     * global variables.
     *
     * The advantage is to put all the logic at the same place, making the code
     * easier to understand, and also to remove one level of function call since
     * the body is inlined by the compiler.
     */
    app.repeat(2000, [] () { led2.toggle(); });

    /*
     * Option 3: use a lambda function, which closure includes by default
     * static local variables.
     *
     * This is basically the same as option 2, but has the advantage of putting
     * variables in the narrower possible scope, which is usually a better
     * practice than placing them in the global scope. 
     */
    static SimulatedLed led3(3);
    app.repeat(3000, [] () { led3.toggle(); });

    /*
      Unfortunately, we can't use local captures to register callbacks this way:

      SimulatedLed led4(4);
      app.repeat(300, [&led4] () { led4.toggle(); });

      The reason is that the callback is declared as void (*)(void), with does
      not match the function generated by the compiler when dynamic locals are 
      captured (they are passed as arguments to it).
    */

}

// let's start the reactor with our application
Reactduino app(app_main);
